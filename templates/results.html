<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analysis Results - Trace Endpoint Analyzer</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>

<body>
    {% macro render_trace_node(node, loop_index, total_trace_time, parent_total_time) %}
    {# Calculate percentage of total trace time #}
    {% set total_perc = (node.total_time_ms / total_trace_time * 100) if total_trace_time > 0 else 0 %}
    {% set self_perc = (node.self_time_ms / total_trace_time * 100) if total_trace_time > 0 else 0 %}

    {# Default expansion logic: Only expand nodes contributing > 10% to total time #}
    {% set initial_state = 'expanded' if (node.children and total_perc >= 10) else 'collapsed' if node.children else ''
    %}

    <li class="{{ 'collapsible' if node.children }} trace-node {{ 'error-span' if node.is_error }}"
        data-state="{{ initial_state }}" data-total-time="{{ node.total_time_ms }}" data-trace-percent="{{ "
        %.1f"|format(total_perc) }}" data-self-percent="{{ " %.1f"|format(self_perc) }}" {% if node.is_error %}
        data-error="true" data-error-message="{{ node.error_message }}" {% if node.http_status_code %}
        data-http-status="{{ node.http_status_code }}" {% endif %} {% endif %}>
        <div class="node-content">
            <div class="node-main">
                {% if node.children %}
                <span class="toggle"></span>
                {% endif %}
                <span class="node-prefix">{{ loop_index }}.</span>
                {% if node.is_error %}
                <span class="error-indicator" title="Error: {{ node.error_message }}">üî¥</span>
                {% endif %}
                <span class="node-service">{{ node.service_name }}</span>
                <span class="node-arrow">‚Üí</span>
                <span class="node-name">{{ node.span.name }}</span>
            </div>
            <div class="node-metrics">
                <span class="metric count"><strong>Count:</strong> {{ node.count }}</span>
                {% if node.aggregated %}
                <span class="metric avg-time"><strong>Avg:</strong> {{ "%.2f"|format(node.avg_time_ms) }} ms</span>
                {% endif %}

                {% if node.is_error %}
                <span class="metric error-badge" title="{{ node.error_message }}">
                    <strong>‚ùå Error{% if node.aggregated and node.error_count %} ({{ node.error_count }}/{{ node.count
                        }}){% elif node.http_status_code %} ({{ node.http_status_code }}){% endif %}</strong>
                </span>
                {% endif %}

                {# For parallel aggregated nodes: show Effective as primary, Cumulative as secondary #}
                {% if node.aggregated and node.parallelism_factor is defined and node.parallelism_factor > 1 and node.wall_clock_ms %}
                {% set effective_perc = (node.wall_clock_ms / total_trace_time * 100) if total_trace_time > 0 else 0 %}
                <span class="metric effective-time-primary" title="Actual wall-clock time for these {{ node.count }} parallel calls">
                    <strong>‚ö° Effective:</strong> {{ "%.2f"|format(node.wall_clock_ms) }} ms ({{ "%.1f"|format(effective_perc) }}%)
                </span>
                <span class="metric cumulative-time-secondary" title="Sum of all {{ node.count }} individual call durations">
                    <strong>Cumulative:</strong> {{ "%.2f"|format(node.total_time_ms) }} ms (√ó{{ node.count }} calls, {{ "%.1f"|format(node.parallelism_factor) }}√ó parallel)
                </span>
                {% else %}
                {# Standard display for non-parallel nodes #}
                <span class="metric total-time">
                    <strong>Total:</strong> {{ "%.2f"|format(node.total_time_ms) }} ms ({{ "%.1f"|format(total_perc) }}%)
                </span>
                {% endif %}

                {% set self_perc = (node.self_time_ms / total_trace_time * 100) if total_trace_time > 0 else 0 %}
                <span class="metric self-time">
                    <strong>Self:</strong> {{ "%.2f"|format(node.self_time_ms) }} ms ({{ "%.1f"|format(self_perc) }}%)
                </span>
                
                {# Visual indicator on parent nodes that have parallel children #}
                {% if node.has_parallel_children %}
                <span class="metric has-parallel-badge" title="This node has children running in parallel">
                    ‚§µ‚§µ
                </span>
                {% endif %}
                
                {# Sibling parallelism indicator on parent nodes (cross-service parallel calls) #}
                {% if node.sibling_parallelism %}
                <span class="metric sibling-parallel-badge" title="Children ran in parallel - wall-clock time reduced">
                    <strong>‚à• {{ "%.1f"|format(node.sibling_parallelism_factor) }}√ó parallel</strong>
                    <span class="sibling-details">({{ node.parallel_sibling_count }} siblings: {{ "%.0f"|format(node.sibling_cumulative_time_ms) }}ms cumulative ‚Üí {{ "%.0f"|format(node.sibling_effective_time_ms) }}ms effective)</span>
                </span>
                {% endif %}
                
                {# Marker on individual sibling nodes that are part of parallel group #}
                {% if node.is_parallel_sibling %}
                <span class="metric parallel-sibling-marker" title="Part of parallel sibling group ({{ "%.1f"|format(node.total_time_ms) }}ms)">‚à•</span>
                {% endif %}
            </div>
        </div>
        {% if node.children %}
        <ul>
            {% for child in node.children %}
            {{ render_trace_node(child, loop.index, total_trace_time, node.total_time_ms) }}
            {% endfor %}
        </ul>
        {% endif %}
    </li>
    {% endmacro %}
    <div class="container">
        <header>
            <h1>üìä Analysis Results</h1>
            <p class="subtitle">{{ filename }}</p>
            <a href="/" class="btn btn-secondary">‚Üê Analyze Another File</a>
        </header>

        <main>
            <!-- Summary Section -->
            <section class="summary-section">
                <h2>Summary Statistics</h2>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value">{{ results.summary.total_requests }}</div>
                        <div class="stat-label">Total Requests</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">{{ results.summary.total_time_formatted }}</div>
                        <div class="stat-label">Total Time</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">{{ results.summary.unique_services }}</div>
                        <div class="stat-label">Unique Services</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">{{ results.summary.unique_combinations }}</div>
                        <div class="stat-label">Endpoint Combinations</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">{{ results.summary.total_traces }}</div>
                        <div class="stat-label">Total Traces</div>
                    </div>
                    {% if results.summary.total_kafka_operations > 0 %}
                    <div class="stat-card">
                        <div class="stat-value">{{ results.summary.total_kafka_operations }}</div>
                        <div class="stat-label">Kafka Operations</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">{{ results.summary.total_kafka_time_formatted }}</div>
                        <div class="stat-label">Kafka Total Time</div>
                    </div>
                    {% endif %}
                    {% if results.summary.total_errors > 0 %}
                    <div class="stat-card error">
                        <div class="stat-value">{{ results.summary.total_errors }}</div>
                        <div class="stat-label">Total Errors</div>
                    </div>
                    {% endif %}
                </div>
            </section>

            <!-- Trace Hierarchy -->
            {% if results.trace_hierarchies %}
            <section class="trace-hierarchy-section">
                <h2>Trace Hierarchy</h2>
                <p class="section-note">Hierarchical view of each trace, showing self-time and aggregated calls.</p>
                <div class="hierarchy-controls">
                    <button class="btn btn-sm btn-expand-all">Expand All</button>
                    <button class="btn btn-sm btn-collapse-all">Collapse All</button>
                    <div class="error-filter-container">
                        <label for="show-errors-only"
                            style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="checkbox" id="show-errors-only" style="cursor: pointer;">
                            <span>Show Errors Only</span>
                        </label>
                    </div>
                    <div class="performance-filter-container">
                        <label for="show-performance-only"
                            style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="checkbox" id="show-performance-only" style="cursor: pointer;">
                            <span>Show Performance Issues Only</span>
                        </label>
                    </div>
                    <div class="highlight-slider-container">
                        <label for="highlight-threshold">
                            Highlight nodes contributing: <strong><span id="threshold-value">10</span>%+</strong>
                        </label>
                        <input type="range" id="highlight-threshold" min="5" max="95" value="10" step="5">
                        <span class="slider-hint">Move slider to adjust highlighting threshold</span>
                    </div>
                </div>

                {% for trace_id, hierarchy in results.trace_hierarchies.items() %}
                <div class="trace-detail">
                    <div class="trace-header">
                        <h3>Trace ID: <span class="trace-id">{{ trace_id }}</span></h3>
                        <div class="trace-summary-stats">
                            <span><strong>Wall-Clock Duration:</strong> {{
                                results.trace_summary[trace_id].wall_clock_duration_formatted }}</span>
                            <span><strong>Total Spans:</strong> {{ results.trace_summary[trace_id].span_count }}</span>
                        </div>
                    </div>

                    <div class="tree">
                        <ul>
                            {% for node in hierarchy.children %}
                            {{ render_trace_node(node, loop.index,
                            results.trace_summary[trace_id].wall_clock_duration_ms, hierarchy.total_time_ms) }}
                            {% endfor %}
                        </ul>
                    </div>
                </div>
                {% endfor %}
            </section>
            {% endif %}

            <!-- Services Overview -->
            <section class="services-overview">
                <h2>Services Overview</h2>
                <div class="table-wrapper">
                    <table class="sortable-table">
                        <thead>
                            <tr>
                                <th>Service Name</th>
                                <th class="sortable" data-sort="number">Requests <span class="sort-icon"></span></th>
                                <th class="sortable" data-sort="time">Total Time <span class="sort-icon"></span></th>
                                <th class="sortable" data-sort="time">Self Time <span class="sort-icon"></span></th>
                                <th class="sortable" data-sort="number">Unique Endpoints <span class="sort-icon"></span>
                                </th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for service in results.services.summary %}
                            <tr>
                                <td class="service-name">
                                    <a href="#service-{{ loop.index }}">{{ service.name }}</a>
                                </td>
                                <td>{{ service.request_count }}</td>
                                <td class="time-cell">{{ service.total_time_formatted }}</td>
                                <td class="time-cell">{{ service.total_self_time_formatted }}</td>
                                <td>{{ service.unique_combinations }}</td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
            </section>

            <!-- Incoming Requests by Service -->
            <section class="endpoints-section">
                <h2>Incoming Requests by Service</h2>
                <p class="section-note">Endpoints sorted by total time (slowest first)</p>

                {% for service in results.services.summary %}
                <div class="service-detail" id="service-{{ loop.index }}">
                    <h3>{{ service.name }}</h3>
                    <div class="service-stats">
                        <span><strong>Requests:</strong> {{ service.request_count }}</span>
                        <span><strong>Total Time:</strong> {{ service.total_time_formatted }}</span>
                        <span><strong>Self Time:</strong> {{ service.total_self_time_formatted }}</span>
                        <span><strong>Unique:</strong> {{ service.unique_combinations }}</span>
                    </div>

                    <div class="table-wrapper">
                        <table class="sortable-table">
                            <thead>
                                <tr>
                                    <th>Normalized Endpoint</th>
                                    <th>Parameter Value</th>
                                    <th class="sortable" data-sort="number">Count <span class="sort-icon"></span></th>
                                    <th class="sortable" data-sort="time">Total Time <span class="sort-icon"></span>
                                    </th>
                                    <th class="sortable" data-sort="time">Self Time <span class="sort-icon"></span></th>
                                </tr>
                            </thead>
                            <tbody>
                                {% for endpoint in results.services.details[service.name] %}
                                <tr>
                                    <td class="endpoint-cell"><span class="http-method">{{ endpoint.http_method
                                            }}</span> {{ endpoint.endpoint }}</td>
                                    <td class="param-cell">
                                        {% if endpoint.parameter|length > 50 %}
                                        <span title="{{ endpoint.parameter }}">{{ endpoint.parameter[:47] }}...</span>
                                        {% else %}
                                        {{ endpoint.parameter }}
                                        {% endif %}
                                    </td>
                                    <td>{{ endpoint.count }}</td>
                                    <td class="time-cell">{{ endpoint.total_time_formatted }}</td>
                                    <td class="time-cell">{{ endpoint.total_self_time_formatted }}</td>
                                </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                    </div>
                </div>
                {% endfor %}
            </section>

            <!-- Service-to-Service Calls -->
            {% if results.service_calls %}
            <section class="service-calls-section">
                <h2>Service-to-Service Calls</h2>
                <p class="section-note">Outgoing HTTP calls between services, sorted by total time</p>

                {% for call_pair in results.service_calls %}
                <div class="service-call-detail">
                    <h3>{{ call_pair.caller }} ‚Üí {{ call_pair.callee }}</h3>
                    <div class="service-stats">
                        <span><strong>Total Calls:</strong> {{ call_pair.total_calls }}</span>
                        <span><strong>Total Time:</strong> {{ call_pair.total_time_formatted }}</span>
                        <span><strong>Self Time:</strong> {{ call_pair.total_self_time_formatted }}</span>
                        <span><strong>Unique Endpoints:</strong> {{ call_pair.calls|length }}</span>
                    </div>

                    <div class="table-wrapper">
                        <table class="sortable-table">
                            <thead>
                                <tr>
                                    <th>Normalized Endpoint</th>
                                    <th>Parameter Value</th>
                                    <th class="sortable" data-sort="number">Count <span class="sort-icon"></span></th>
                                    <th class="sortable" data-sort="time">Total Time <span class="sort-icon"></span>
                                    </th>
                                    <th class="sortable" data-sort="time">Self Time <span class="sort-icon"></span></th>
                                </tr>
                            </thead>
                            <tbody>
                                {% for call in call_pair.calls %}
                                <tr>
                                    <td class="endpoint-cell"><span class="http-method">{{ call.http_method }}</span> {{
                                        call.endpoint }}</td>
                                    <td class="param-cell">
                                        {% if call.parameter|length > 50 %}
                                        <span title="{{ call.parameter }}">{{ call.parameter[:47] }}...</span>
                                        {% else %}
                                        {{ call.parameter }}
                                        {% endif %}
                                    </td>
                                    <td>{{ call.count }}</td>
                                    <td class="time-cell">{{ call.total_time_formatted }}</td>
                                    <td class="time-cell">{{ call.total_self_time_formatted }}</td>
                                </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                    </div>
                </div>
                {% endfor %}
            </section>
            {% endif %}

            <!-- Kafka/Messaging Operations -->
            {% if results.kafka_operations %}
            <section class="kafka-operations-section">
                <h2>Kafka/Messaging Operations</h2>
                <p class="section-note">Kafka consumer/producer operations and message processing, sorted by total time
                </p>

                {% for kafka_service in results.kafka_operations %}
                <div class="kafka-service-detail">
                    <h3>{{ kafka_service.service }}</h3>
                    <div class="service-stats">
                        <span><strong>Total Operations:</strong> {{ kafka_service.total_operations }}</span>
                        <span><strong>Total Time:</strong> {{ kafka_service.total_time_formatted }}</span>
                        <span><strong>Unique Operations:</strong> {{ kafka_service.operations|length }}</span>
                    </div>

                    <div class="table-wrapper">
                        <table class="sortable-table">
                            <thead>
                                <tr>
                                    <th>Operation Type</th>
                                    <th>Message/Span Name</th>
                                    <th>Details</th>
                                    <th class="sortable" data-sort="number">Count <span class="sort-icon"></span></th>
                                    <th class="sortable" data-sort="time">Total Time <span class="sort-icon"></span>
                                    </th>
                                </tr>
                            </thead>
                            <tbody>
                                {% for operation in kafka_service.operations %}
                                <tr>
                                    <td class="operation-type">{{ operation.operation }}</td>
                                    <td class="message-type">{{ operation.message_type }}</td>
                                    <td class="details-cell">
                                        {% if operation.details|length > 60 %}
                                        <span title="{{ operation.details }}">{{ operation.details[:57] }}...</span>
                                        {% else %}
                                        {{ operation.details }}
                                        {% endif %}
                                    </td>
                                    <td>{{ operation.count }}</td>
                                    <td class="time-cell">{{ operation.total_time_formatted }}</td>
                                </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                    </div>
                </div>
                {% endfor %}
            </section>
            {% endif %}

            <!-- Error Summary Section -->
            {% if results.error_analysis %}
            <section class="error-summary-section">
                <h2>üö® Error Summary by Service</h2>
                <p class="section-note">Summary of failed operations (spans marked with an error status), sorted by
                    error count.</p>

                {% for service, errors in results.error_analysis.items() %}
                <div class="service-detail">
                    <h3>{{ service }}</h3>
                    <div class="table-wrapper">
                        <table class="sortable-table">
                            <thead>
                                <tr>
                                    <th>Operation Type</th>
                                    <th>Endpoint / Details</th>
                                    <th class="sortable" data-sort="number">Error Count <span class="sort-icon"></span>
                                    </th>
                                    <th>Top Error Messages</th>
                                </tr>
                            </thead>
                            <tbody>
                                {% for error in errors %}
                                <tr>
                                    <td class="operation-type">{{ error.type }}</td>
                                    <td class="endpoint-cell">
                                        <span class="http-method">{{ error.http_method }}</span>
                                        {{ error.endpoint }}
                                        {% if error.parameter %}
                                        <span class="param-cell" title="{{ error.parameter }}">({{ error.parameter
                                            }})</span>
                                        {% endif %}
                                    </td>
                                    <td>{{ error.error_count }}</td>
                                    <td class="error-messages">
                                        <ul>
                                            {% for message, count in error.top_messages %}
                                            <li><strong>({{ count }}x)</strong> {{ message }}</li>
                                            {% endfor %}
                                        </ul>
                                    </td>
                                </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                    </div>
                </div>
                {% endfor %}
            </section>
            {% endif %}
        </main>

        <footer>
            <a href="/" class="btn btn-primary">Analyze Another File</a>
            <p style="text-align: center; margin-top: 20px; font-size: 0.9em;">
                <a href="https://github.com/vikrant82/trace_analyzer" target="_blank">View on GitHub</a>
            </p>
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // Table sorting functionality
            const tables = document.querySelectorAll('.sortable-table');
            tables.forEach(table => {
                const headers = table.querySelectorAll('th.sortable');
                headers.forEach(header => {
                    header.addEventListener('click', () => {
                        const allHeaders = Array.from(table.querySelectorAll('th'));
                        const columnIndex = allHeaders.indexOf(header);
                        sortTable(table, columnIndex, header.dataset.sort);
                    });
                });
            });

            // Trace hierarchy collapse/expand functionality
            const hierarchySection = document.querySelector('.trace-hierarchy-section');
            if (hierarchySection) {
                hierarchySection.addEventListener('click', function (e) {
                    if (e.target.classList.contains('toggle')) {
                        const parentLi = e.target.closest('li.collapsible');
                        if (parentLi) {
                            const currentState = parentLi.dataset.state;
                            parentLi.dataset.state = currentState === 'expanded' ? 'collapsed' : 'expanded';
                        }
                    }
                });

                const expandAllBtn = hierarchySection.querySelector('.btn-expand-all');
                const collapseAllBtn = hierarchySection.querySelector('.btn-collapse-all');

                expandAllBtn.addEventListener('click', () => {
                    const allCollapsible = hierarchySection.querySelectorAll('li.collapsible');
                    allCollapsible.forEach(li => li.dataset.state = 'expanded');
                });

                collapseAllBtn.addEventListener('click', () => {
                    const allCollapsible = hierarchySection.querySelectorAll('li.collapsible');
                    allCollapsible.forEach(li => li.dataset.state = 'collapsed');
                });

                // Error filter checkbox functionality
                const errorFilterCheckbox = document.getElementById('show-errors-only');

                if (errorFilterCheckbox) {
                    errorFilterCheckbox.addEventListener('change', function () {
                        filterErrorNodes(this.checked);
                    });
                }

                function filterErrorNodes(showErrorsOnly) {
                    const allNodes = hierarchySection.querySelectorAll('.trace-node');

                    allNodes.forEach(node => {
                        if (showErrorsOnly) {
                            // Only show error nodes and their ancestors
                            const isError = node.dataset.error === 'true';
                            const hasErrorDescendant = hasErrorInSubtree(node);

                            if (isError || hasErrorDescendant) {
                                node.style.display = '';
                                // Auto-expand nodes with errors to show them
                                if (node.classList.contains('collapsible') && hasErrorDescendant) {
                                    node.dataset.state = 'expanded';
                                }
                            } else {
                                node.style.display = 'none';
                            }
                        } else {
                            // Show all nodes
                            node.style.display = '';
                        }
                    });
                }

                function hasErrorInSubtree(node) {
                    // Check if this node has error attribute
                    if (node.dataset.error === 'true') {
                        return true;
                    }

                    // Check all descendant nodes
                    const descendants = node.querySelectorAll('.trace-node');
                    for (let desc of descendants) {
                        if (desc.dataset.error === 'true') {
                            return true;
                        }
                    }

                    return false;
                }

                // Performance filter checkbox functionality
                const performanceFilterCheckbox = document.getElementById('show-performance-only');

                if (performanceFilterCheckbox) {
                    performanceFilterCheckbox.addEventListener('change', function () {
                        filterPerformanceNodes(this.checked);
                    });
                }

                function filterPerformanceNodes(showPerformanceOnly) {
                    const allNodes = hierarchySection.querySelectorAll('.trace-node');

                    allNodes.forEach(node => {
                        if (showPerformanceOnly) {
                            // Only show performance-highlighted nodes and their ancestors
                            const isHighlighted = node.classList.contains('time-highlighted') ||
                                node.classList.contains('self-time-highlighted');
                            const hasHighlightedDescendant = hasHighlightedInSubtree(node);

                            if (isHighlighted || hasHighlightedDescendant) {
                                node.style.display = '';
                                // Auto-expand nodes with performance issues to show them
                                if (node.classList.contains('collapsible') && hasHighlightedDescendant) {
                                    node.dataset.state = 'expanded';
                                }
                            } else {
                                node.style.display = 'none';
                            }
                        } else {
                            // Show all nodes
                            node.style.display = '';
                        }
                    });
                }

                function hasHighlightedInSubtree(node) {
                    // Check if this node is highlighted
                    if (node.classList.contains('time-highlighted') ||
                        node.classList.contains('self-time-highlighted')) {
                        return true;
                    }

                    // Check all descendant nodes
                    const descendants = node.querySelectorAll('.trace-node');
                    for (let desc of descendants) {
                        if (desc.classList.contains('time-highlighted') ||
                            desc.classList.contains('self-time-highlighted')) {
                            return true;
                        }
                    }

                    return false;
                }

                // Highlighting slider functionality
                const slider = document.getElementById('highlight-threshold');
                const thresholdDisplay = document.getElementById('threshold-value');

                if (slider && thresholdDisplay) {
                    // Apply initial highlighting
                    updateHighlighting(slider.value);

                    // Update on slider change
                    slider.addEventListener('input', function () {
                        const threshold = this.value;
                        thresholdDisplay.textContent = threshold;
                        updateHighlighting(threshold);
                    });
                }

                function updateHighlighting(threshold) {
                    const allNodes = hierarchySection.querySelectorAll('.trace-node');

                    allNodes.forEach(node => {
                        const tracePercent = parseFloat(node.dataset.tracePercent || 0);
                        const selfPercent = parseFloat(node.dataset.selfPercent || 0);

                        // Remove all highlight classes
                        node.classList.remove('time-highlighted', 'self-time-highlighted');

                        // Add highlight if above threshold
                        if (selfPercent >= threshold) {
                            // High self-time means this specific node is slow (Bottleneck)
                            node.classList.add('self-time-highlighted');
                        } else if (tracePercent >= threshold) {
                            // High total-time means this is part of the slow path (Hot Path)
                            node.classList.add('time-highlighted');
                        }
                    });

                    // Re-apply performance filter if it's active
                    const performanceFilterCheckbox = document.getElementById('show-performance-only');
                    if (performanceFilterCheckbox && performanceFilterCheckbox.checked) {
                        filterPerformanceNodes(true);
                    }
                }
            }
        });

        function sortTable(table, columnIndex, sortType) {
            const tbody = table.querySelector('tbody');
            if (!tbody) return;

            const rows = Array.from(tbody.querySelectorAll('tr'));
            if (rows.length === 0) return;

            const allHeaders = table.querySelectorAll('th');
            const header = allHeaders[columnIndex];
            if (!header) return;

            const currentSort = header.dataset.currentSort || 'none';

            // Clear all sort indicators
            allHeaders.forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
                th.dataset.currentSort = 'none';
            });

            // Determine sort direction
            let sortOrder = 'asc';
            if (currentSort === 'asc') {
                sortOrder = 'desc';
            }

            // Sort rows
            rows.sort((a, b) => {
                const aCell = a.cells[columnIndex];
                const bCell = b.cells[columnIndex];

                if (!aCell || !bCell) return 0;

                const aValue = aCell.textContent.trim();
                const bValue = bCell.textContent.trim();

                let comparison = 0;

                if (sortType === 'number') {
                    const aNum = parseInt(aValue.replace(/,/g, '')) || 0;
                    const bNum = parseInt(bValue.replace(/,/g, '')) || 0;
                    comparison = aNum - bNum;
                } else if (sortType === 'time') {
                    const aMs = parseTimeToMs(aValue);
                    const bMs = parseTimeToMs(bValue);
                    comparison = aMs - bMs;
                } else {
                    comparison = aValue.localeCompare(bValue);
                }

                return sortOrder === 'asc' ? comparison : -comparison;
            });

            // Update table
            rows.forEach(row => tbody.appendChild(row));

            // Update sort indicator
            header.classList.add(sortOrder === 'asc' ? 'sort-asc' : 'sort-desc');
            header.dataset.currentSort = sortOrder;
        }

        function parseTimeToMs(timeStr) {
            // Parse time strings like "12.45 s", "245.50 ms", "2m 15.30s"
            let ms = 0;

            // Match minutes
            const minMatch = timeStr.match(/(\d+)m/);
            if (minMatch) {
                ms += parseInt(minMatch[1]) * 60000;
            }

            // Match seconds
            const secMatch = timeStr.match(/([\d.]+)\s*s/);
            if (secMatch) {
                ms += parseFloat(secMatch[1]) * 1000;
            }

            // Match milliseconds
            const msMatch = timeStr.match(/([\d.]+)\s*ms/);
            if (msMatch) {
                ms += parseFloat(msMatch[1]);
            }

            return ms;
        }
    </script>
</body>

</html>